(window.webpackJsonpngx_snake=window.webpackJsonpngx_snake||[]).push([[113,179],{113:(t,e,s)=>{"use strict";let i;s.r(e),s.d(e,{CustomStrategy:()=>a}),function(t){t[t.left=37]="left",t[t.up=38]="up",t[t.right=39]="right",t[t.down=40]="down"}(i||(i={}));const n=class{get size(){return this.items.length-1}constructor(t){var e,s,i;this.shouldBeBefore=t,i=[],(s="items")in(e=this)?Object.defineProperty(e,s,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[s]=i,this.items.length=1}getParentIndexOf(t){return 1===t?t:Math.floor(t/2)}getLeftChildIndexOf(t){return 2*t}getRightChildIndexOf(t){return 2*t+1}siftUp(t){if(1===t)return;const e=this.items[t],s=this.getParentIndexOf(t),i=this.items[s];this.shouldBeBefore(e,i)&&(this.items[s]=e,this.items[t]=i,this.siftUp(s))}siftDown(t){const e=this.items[t],s=this.getLeftChildIndexOf(t),i=this.getRightChildIndexOf(t),n=this.items[s],o=this.items[i];if(!n&&!o)return;const r=!o||this.shouldBeBefore(n,o)?s:i,a=this.items[r];this.shouldBeBefore(e,a)||(this.items[r]=e,this.items[t]=a,this.siftDown(r))}add(t){this.items.push(t),this.siftUp(this.items.length-1)}peek(){return this.items[1]}pop(){if(0===this.size)return;const t=this.items[1],e=this.items[this.size];return this.items[1]=e,this.items.pop(),this.siftDown(1),t}popAll(){const t=[];for(;0!==this.size;)t.push(this.pop());return t}};function o(t,e,s){const i=function(t){const e=[];let s=t;for(;s;)e.unshift(r(s,"previousNode")),s=s.previousNode;return e}(t);return{cost:t.g,expandedNodeCounter:e,getExpandedNodes:()=>s.values(),getPath:()=>i,isFail:()=>!1,isSuccess:()=>!0,status:"success",target:i[i.length-1]}}const r=(t,...e)=>{let s,i={};for(s in t)e.includes(s)||(i[s]=t[s]);return i};class a{step(t){const e=h.findPath({startNode:t,isEnd:e=>u(e.snake.parts[0])===u(t.fruit),estimateCost:e=>{const s=e.snake.parts[0],i=Math.abs(s.x-t.fruit.x),n=18-i,o=Math.abs(s.y-t.fruit.y),r=18-o;return Math.min(i,n)+Math.min(o,r)},maxCosts:50});if(e.isFail())return console.log("Error - no path found!"),i.left;{const s=e.getPath()[1].data,n=t.snake.parts[0],o=s.snake.parts[0];return o.x===n.x+1||o.x===n.x+1-18?i.right:o.x===n.x-1||o.x===n.x-1+18?i.left:o.y===n.y+1||o.y===n.y+1-18?i.down:o.y===n.y-1||o.y===n.y-1+18?i.up:i.left}}}const h=new class{constructor(t){var e,s,i;i=void 0,(s="config")in(e=this)?Object.defineProperty(e,s,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[s]=i,this.config={hashData:t=>JSON.stringify(t),getNeighbourCost:()=>1,...t}}findPath(t){return function(t){const{estimateCost:e=(()=>0),getNeighbourCost:s=(()=>1),getNeighbours:i,hashData:r=(t=>t.toString()),heapComperator:a=((t,e)=>t.f-e.f),isEnd:h,maxCosts:u=1/0,startNode:f}=t,c={data:f,g:0,h:e(f),f:e(f),hash:r(f)},d=new Map,l=new n((t,e)=>a(t,e)<0),p=new Map;d.set(c.hash,c),l.add(c);let g=0;for(;0!==l.size;){const t=l.pop();if(!d.has(t.hash))continue;if(d.delete(t.hash),p.set(t.hash,t),h(t.data))return o(t,g,p);if(t.g>u)return o(t,g,p);g++;const n=i(t.data);for(let i=0;i<n.length;i++){const o=n[i],a=r(o);if(p.has(a))continue;const h=t.g+s(t.data,o),u=d.get(a);if(void 0!==u&&h>=u.g)continue;const f=e(o),c={data:o,f:h+f,h:f,g:h,hash:a,previousNode:t};d.set(a,c),l.add(c)}}return function(t,e){return{expandedNodeCounter:e,getExpandedNodes:()=>t.values(),isFail:()=>!0,isSuccess:()=>!1,status:"Fail :("}}(p,g)}({...t,...this.config})}}({getNeighbours:t=>{const e=t.snake.parts,{x:s,y:i}=e[0],n=[{x:s+1,y:i},{x:s,y:i+1},{x:s-1,y:i},{x:s,y:i-1}];for(const t of n)t.x<0&&(t.x=17),t.y<0&&(t.y=17),18===t.y&&(t.y=0),18===t.x&&(t.x=0);const o=e.slice(0,-1),r=t.obstacles.map(u),a=e.map(u);return n.filter(t=>{const e=u(t);return!r.includes(e)&&!a.includes(e)}).map(e=>({...t,snake:{...t.snake,parts:[e,...o]}}))},hashData:t=>t.snake.parts.slice(0,5).map(u).join(" --- ")});function u(t){return`${t.x}-${t.y}`}}}]);