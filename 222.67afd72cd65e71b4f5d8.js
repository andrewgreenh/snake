(window.webpackJsonpngx_snake=window.webpackJsonpngx_snake||[]).push([[222,179],{222:(t,s,e)=>{"use strict";let i;function n(t,s,e){return s in t?Object.defineProperty(t,s,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[s]=e,t}e.r(s),e.d(s,{CustomStrategy:()=>o}),function(t){t[t.left=37]="left",t[t.up=38]="up",t[t.right=39]="right",t[t.down=40]="down"}(i||(i={}));class o{constructor(){n(this,"graph",r())}step(t){const s=this.graph.findPath({startNode:t,isEnd:s=>a(s.snake.parts[0])===a(t.fruit),estimateCost:s=>{const e=s.snake.parts[0],i=Math.abs(e.x-t.fruit.x),n=18-i,o=Math.abs(e.y-t.fruit.y),r=18-o;return Math.min(i,n)+Math.min(o,r)},maxCosts:50});if(s.isFail())return console.log("Error - no path found!"),i.left;{const e=s.getPath()[1].data,n=t.snake.parts[0],o=e.snake.parts[0];return o.x===n.x+1||o.x===n.x+1-18?i.right:o.x===n.x-1||o.x===n.x-1+18?i.left:o.y===n.y+1||o.y===n.y+1-18?i.down:o.y===n.y-1||o.y===n.y-1+18?i.up:i.left}}}const r=()=>new h({getNeighbours:t=>{const s=t.snake.parts,{x:e,y:i}=s[0],n=[{x:e+1,y:i},{x:e,y:i+1},{x:e-1,y:i},{x:e,y:i-1}];for(const t of n)t.x<0&&(t.x=17),t.y<0&&(t.y=17),18===t.y&&(t.y=0),18===t.x&&(t.x=0);const o=s.slice(0,-1),r=t.obstacles.map(a),h=s.map(a);return n.filter(t=>{const s=a(t);return!r.includes(s)&&!h.includes(s)}).map(s=>({...t,snake:{...t.snake,parts:[s,...o]}}))},hashData:t=>t.snake.parts.slice(0,5).map(a).join(" --- ")});function a(t){return`${t.x}-${t.y}`}class h{constructor(t){n(this,"config",void 0),this.config={hashData:t=>JSON.stringify(t),getNeighbourCost:()=>1,...t}}findPath(t){return function(t){const{estimateCost:s=(()=>0),getNeighbourCost:e=(()=>1),getNeighbours:i,hashData:n=(t=>t.toString()),heapComperator:o=((t,s)=>t.f-s.f),isEnd:r,maxCosts:a=1/0,startNode:h}=t,f={data:h,g:0,h:s(h),f:s(h),hash:n(h)},d=new Map,p=new c((t,s)=>o(t,s)<0),g=new Map;d.set(f.hash,f),p.add(f);let l=0;for(;0!==p.size;){const t=p.pop();if(!d.has(t.hash))continue;if(d.delete(t.hash),g.set(t.hash,t),r(t.data))return u(t,l,g);if(t.g>a)return u(t,l,g);l++;const o=i(t.data);for(let i=0;i<o.length;i++){const r=o[i],a=n(r);if(g.has(a))continue;const h=t.g+e(t.data,r),u=d.get(a);if(void 0!==u&&h>=u.g)continue;const f=s(r),c={data:r,f:h+f,h:f,g:h,hash:a,previousNode:t};d.set(a,c),p.add(c)}}return function(t,s){return{expandedNodeCounter:s,getExpandedNodes:()=>t.values(),isFail:()=>!0,isSuccess:()=>!1,status:"Fail :("}}(g,l)}({...t,...this.config})}}function u(t,s,e){const i=function(t){const s=[];let e=t;for(;e;)s.unshift(f(e,"previousNode")),e=e.previousNode;return s}(t);return{cost:t.g,expandedNodeCounter:s,getExpandedNodes:()=>e.values(),getPath:()=>i,isFail:()=>!1,isSuccess:()=>!0,status:"success",target:i[i.length-1]}}const f=(t,...s)=>{let e,i={};for(e in t)s.includes(e)||(i[e]=t[e]);return i};class c{get size(){return this.items.length-1}constructor(t){this.shouldBeBefore=t,n(this,"items",[]),this.items.length=1}getParentIndexOf(t){return 1===t?t:Math.floor(t/2)}getLeftChildIndexOf(t){return 2*t}getRightChildIndexOf(t){return 2*t+1}siftUp(t){if(1===t)return;const s=this.items[t],e=this.getParentIndexOf(t),i=this.items[e];this.shouldBeBefore(s,i)&&(this.items[e]=s,this.items[t]=i,this.siftUp(e))}siftDown(t){const s=this.items[t],e=this.getLeftChildIndexOf(t),i=this.getRightChildIndexOf(t),n=this.items[e],o=this.items[i];if(!n&&!o)return;const r=!o||this.shouldBeBefore(n,o)?e:i,a=this.items[r];this.shouldBeBefore(s,a)||(this.items[r]=s,this.items[t]=a,this.siftDown(r))}add(t){this.items.push(t),this.siftUp(this.items.length-1)}peek(){return this.items[1]}pop(){if(0===this.size)return;const t=this.items[1],s=this.items[this.size];return this.items[1]=s,this.items.pop(),this.siftDown(1),t}popAll(){const t=[];for(;0!==this.size;)t.push(this.pop());return t}}}}]);